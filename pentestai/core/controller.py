"""
PentestAI Controller - Orchestrates two-stage penetration testing and remediation.

This is the main entry point for the PentestAI framework, coordinating:
- Stage 1: Pentest Module (vulnerability discovery)
- Stage 2: Remediation Module (optimal remediation planning)

Based on the PenHeal paper (arXiv:2407.17788v1), this implements the complete
two-stage LLM framework for automated pentesting and remediation.
"""

import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Any, Optional

from pentestai.core.config import PentestAIConfig
from pentestai.core.pentest_module import PentestModule
from pentestai.core.remediation_module import RemediationModule
from pentestai.llm.client import OpenAIClient, MockLLMClient
from pentestai.models.data import (
    PentestResult,
    RemediationResult,
    Vulnerability,
)

logger = logging.getLogger(__name__)


class PentestAIController:
    """
    Main controller for PentestAI framework.
    
    Orchestrates the complete workflow:
    1. Configuration validation
    2. Stage 1: Pentest Module execution
    3. Stage 2: Remediation Module execution
    4. Results generation and export
    
    Example:
        ```python
        config = PentestAIConfig(
            target="192.168.1.100",
            max_iterations=30,
            remediation_budget=50.0
        )
        
        controller = PentestAIController(config)
        pentest_result, remediation_result = controller.run_full_assessment()
        
        print(f"Found {len(pentest_result.vulnerabilities)} vulnerabilities")
        print(f"Selected {len(remediation_result.selected_strategies)} remediation strategies")
        ```
    """

    def __init__(self, config: PentestAIConfig):
        """
        Initialize PentestAI controller.
        
        Args:
            config: PentestAI configuration
        """
        self.config = config
        
        # Initialize LLM clients
        if config.openai_api_key:
            logger.info("Initializing OpenAI LLM clients")
            self.llm_clients = {
                "planner": OpenAIClient(config.openai_api_key, config.planner_model, config.openai_base_url, config.use_apikey_auth),
                "executor": OpenAIClient(config.openai_api_key, config.executor_model, config.openai_base_url, config.use_apikey_auth),
                "advisor": OpenAIClient(config.openai_api_key, config.advisor_model, config.openai_base_url, config.use_apikey_auth),
                "evaluator": OpenAIClient(config.openai_api_key, config.evaluator_model, config.openai_base_url, config.use_apikey_auth),
                "utility": OpenAIClient(config.openai_api_key, config.utility_model, config.openai_base_url, config.use_apikey_auth),
            }
        else:
            logger.warning("No OpenAI API key provided - using mock LLM clients")
            self.llm_clients = {
                "planner": MockLLMClient(),
                "executor": MockLLMClient(),
                "advisor": MockLLMClient(),
                "evaluator": MockLLMClient(),
                "utility": MockLLMClient(),
            }
        
        # Initialize modules with LLM clients
        self.pentest_module = PentestModule(config, self.llm_clients)
        self.remediation_module = RemediationModule(config, self.llm_clients)
        
        # Setup logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        
        logger.info("PentestAI Controller initialized")
        logger.info(f"Target: {config.target}")
        logger.info(f"Sandbox Mode: {config.sandbox_mode}")
        logger.info(f"LLM Mode: {'OpenAI' if config.openai_api_key else 'Mock (no API key)'}")

    def run_full_assessment(self) -> tuple[PentestResult, RemediationResult]:
        """
        Run complete two-stage assessment: penetration testing + remediation.
        
        Returns:
            Tuple of (PentestResult, RemediationResult)
            
        Raises:
            ValueError: If configuration is invalid
        """
        # Validate configuration
        errors = self.config.validate()
        if errors:
            error_msg = "Configuration errors:\n" + "\n".join(f"  - {e}" for e in errors)
            logger.error(error_msg)
            raise ValueError(error_msg)
        
        logger.info("="*80)
        logger.info("Starting PentestAI Full Assessment")
        logger.info("="*80)
        logger.info(f"Target: {self.config.target}")
        logger.info(f"Max Iterations: {self.config.max_iterations}")
        logger.info(f"Counterfactual Rounds: {self.config.counterfactual_rounds}")
        logger.info(f"Remediation Budget: {self.config.remediation_budget}")
        logger.info("="*80)
        
        start_time = datetime.now()
        
        # Stage 1: Penetration Testing
        logger.info("\n" + "="*80)
        logger.info("STAGE 1: PENTEST MODULE - Vulnerability Discovery")
        logger.info("="*80)
        
        pentest_result = self.pentest_module.run_pentest(self.config.target)
        
        logger.info("\n" + "-"*80)
        logger.info("Stage 1 Results:")
        logger.info(f"  Vulnerabilities Found: {len(pentest_result.vulnerabilities)}")
        logger.info(f"  Tasks Executed: {pentest_result.statistics['tasks_executed']}")
        logger.info(f"  Counterfactual Rounds: {pentest_result.statistics['counterfactual_rounds']}")
        logger.info(f"  Duration: {pentest_result.statistics['duration_seconds']:.2f}s")
        logger.info("-"*80)
        
        # Stage 2: Remediation Planning
        logger.info("\n" + "="*80)
        logger.info("STAGE 2: REMEDIATION MODULE - Optimal Remediation Planning")
        logger.info("="*80)
        
        remediation_result = self.remediation_module.run_remediation(pentest_result.vulnerabilities)
        
        logger.info("\n" + "-"*80)
        logger.info("Stage 2 Results:")
        logger.info(f"  Strategies Generated: {len(remediation_result.all_strategies)}")
        logger.info(f"  Strategies Selected: {len(remediation_result.selected_strategies)}")
        logger.info(f"  Total Value: {remediation_result.total_value:.2f}")
        logger.info(f"  Total Cost: {remediation_result.total_cost:.2f}")
        logger.info(f"  Budget Used: {remediation_result.budget_used:.1f}%")
        logger.info(f"  Optimization Time: {remediation_result.optimization_time:.2f}s")
        logger.info("-"*80)
        
        # Save results
        if self.config.output_directory:
            self._save_results(pentest_result, remediation_result)
        
        end_time = datetime.now()
        total_duration = (end_time - start_time).total_seconds()
        
        logger.info("\n" + "="*80)
        logger.info("Assessment Complete")
        logger.info(f"Total Duration: {total_duration:.2f}s")
        logger.info("="*80)
        
        return pentest_result, remediation_result

    def run_pentest_only(self) -> PentestResult:
        """
        Run only Stage 1 (Pentest Module).
        
        Returns:
            PentestResult
        """
        logger.info("Running Pentest Module only")
        result = self.pentest_module.run_pentest(self.config.target)
        
        if self.config.output_directory:
            self._save_pentest_results(result)
        
        return result

    def run_remediation_only(self, vulnerabilities: list[Vulnerability]) -> RemediationResult:
        """
        Run only Stage 2 (Remediation Module) with provided vulnerabilities.
        
        Args:
            vulnerabilities: List of vulnerabilities to remediate
            
        Returns:
            RemediationResult
        """
        logger.info(f"Running Remediation Module only for {len(vulnerabilities)} vulnerabilities")
        result = self.remediation_module.run_remediation(vulnerabilities)
        
        if self.config.output_directory:
            self._save_remediation_results(result)
        
        return result

    def _save_results(self, pentest_result: PentestResult, remediation_result: RemediationResult) -> None:
        """Save complete assessment results to files."""
        output_dir = Path(self.config.output_directory)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Save JSON results
        results_file = output_dir / f"pentestai_results_{timestamp}.json"
        with open(results_file, "w") as f:
            json.dump({
                "pentest": pentest_result.to_dict(),
                "remediation": remediation_result.to_dict(),
                "config": self.config.to_dict(),
            }, f, indent=2)
        
        logger.info(f"Results saved to: {results_file}")
        
        # Generate human-readable report
        if self.config.generate_report:
            report_file = output_dir / f"pentestai_report_{timestamp}.txt"
            self._generate_report(pentest_result, remediation_result, report_file)
            logger.info(f"Report generated: {report_file}")
        
        # Save attack plan if requested
        if self.config.save_attack_plan and pentest_result.attack_plan:
            plan_file = output_dir / f"attack_plan_{timestamp}.json"
            with open(plan_file, "w") as f:
                json.dump(pentest_result.attack_plan.to_dict(), f, indent=2)
            logger.info(f"Attack plan saved: {plan_file}")

    def _save_pentest_results(self, result: PentestResult) -> None:
        """Save pentest-only results."""
        output_dir = Path(self.config.output_directory)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        results_file = output_dir / f"pentest_results_{timestamp}.json"
        
        with open(results_file, "w") as f:
            json.dump(result.to_dict(), f, indent=2)
        
        logger.info(f"Pentest results saved to: {results_file}")

    def _save_remediation_results(self, result: RemediationResult) -> None:
        """Save remediation-only results."""
        output_dir = Path(self.config.output_directory)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        results_file = output_dir / f"remediation_results_{timestamp}.json"
        
        with open(results_file, "w") as f:
            json.dump(result.to_dict(), f, indent=2)
        
        logger.info(f"Remediation results saved to: {results_file}")

    def _generate_report(
        self,
        pentest_result: PentestResult,
        remediation_result: RemediationResult,
        output_file: Path
    ) -> None:
        """Generate human-readable assessment report."""
        with open(output_file, "w") as f:
            f.write("="*80 + "\n")
            f.write("PENTESTAI ASSESSMENT REPORT\n")
            f.write("="*80 + "\n\n")
            
            # Executive Summary
            f.write("EXECUTIVE SUMMARY\n")
            f.write("-"*80 + "\n")
            f.write(f"Target System: {pentest_result.target}\n")
            f.write(f"Assessment Date: {pentest_result.start_time.strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Total Vulnerabilities: {len(pentest_result.vulnerabilities)}\n")
            f.write(f"Recommended Remediations: {len(remediation_result.selected_strategies)}\n")
            f.write(f"\nSeverity Breakdown:\n")
            
            severity_counts = {}
            for vuln in pentest_result.vulnerabilities:
                severity_counts[vuln.severity.value] = severity_counts.get(vuln.severity.value, 0) + 1
            
            for severity in ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO"]:
                count = severity_counts.get(severity, 0)
                f.write(f"  {severity}: {count}\n")
            
            # Vulnerabilities Detail
            f.write("\n" + "="*80 + "\n")
            f.write("VULNERABILITIES DISCOVERED\n")
            f.write("="*80 + "\n\n")
            
            for i, vuln in enumerate(pentest_result.vulnerabilities, 1):
                f.write(f"{i}. {vuln.name}\n")
                f.write(f"   Severity: {vuln.severity.value} (CVSS: {vuln.cvss_score})\n")
                f.write(f"   Service: {vuln.service}")
                if vuln.port:
                    f.write(f" (Port {vuln.port})")
                f.write("\n")
                if vuln.cve_id:
                    f.write(f"   CVE: {vuln.cve_id}\n")
                f.write(f"   Description: {vuln.description}\n")
                f.write(f"   Exploit Method: {vuln.exploit_method}\n")
                f.write("\n")
            
            # Remediation Recommendations
            f.write("="*80 + "\n")
            f.write("RECOMMENDED REMEDIATION STRATEGIES\n")
            f.write("="*80 + "\n\n")
            
            for i, strategy in enumerate(remediation_result.selected_strategies, 1):
                # Find associated vulnerability
                vuln = next((v for v in pentest_result.vulnerabilities 
                           if v.id == strategy.vulnerability_id), None)
                
                f.write(f"{i}. {strategy.description}\n")
                if vuln:
                    f.write(f"   Addresses: {vuln.name}\n")
                f.write(f"   Type: {strategy.type.value}\n")
                f.write(f"   Effectiveness Score: {strategy.value_score:.2f}/10\n")
                f.write(f"   Cost Score: {strategy.cost_score:.2f}/10\n")
                f.write(f"   Estimated Time: {strategy.estimated_time} minutes\n")
                f.write(f"   Risk Level: {strategy.risk_level}\n")
                
                if strategy.commands:
                    f.write(f"   Commands:\n")
                    for cmd in strategy.commands:
                        f.write(f"     {cmd}\n")
                
                f.write("\n")
            
            # Statistics
            f.write("="*80 + "\n")
            f.write("ASSESSMENT STATISTICS\n")
            f.write("="*80 + "\n\n")
            
            f.write("Pentest Module:\n")
            for key, value in pentest_result.statistics.items():
                f.write(f"  {key}: {value}\n")
            
            f.write("\nRemediation Module:\n")
            for key, value in remediation_result.statistics.items():
                f.write(f"  {key}: {value}\n")
            
            f.write(f"\nTotal Value: {remediation_result.total_value:.2f}\n")
            f.write(f"Total Cost: {remediation_result.total_cost:.2f}\n")
            f.write(f"Budget Used: {remediation_result.budget_used:.1f}%\n")
            
            f.write("\n" + "="*80 + "\n")
            f.write("END OF REPORT\n")
            f.write("="*80 + "\n")

    def get_statistics(
        self,
        pentest_result: PentestResult,
        remediation_result: RemediationResult
    ) -> dict[str, Any]:
        """
        Get comprehensive statistics from assessment results.
        
        Args:
            pentest_result: Pentest results
            remediation_result: Remediation results
            
        Returns:
            Dictionary of statistics
        """
        stats = {
            "pentest": pentest_result.statistics,
            "remediation": remediation_result.statistics,
            "vulnerabilities": {
                "total": len(pentest_result.vulnerabilities),
                "by_severity": {},
                "average_cvss": 0.0,
            },
            "remediation_summary": {
                "total_value": remediation_result.total_value,
                "total_cost": remediation_result.total_cost,
                "budget_used_percent": remediation_result.budget_used,
                "strategies_selected": len(remediation_result.selected_strategies),
                "strategies_total": len(remediation_result.all_strategies),
            }
        }
        
        # Calculate vulnerability statistics
        if pentest_result.vulnerabilities:
            severity_counts = {}
            total_cvss = 0.0
            
            for vuln in pentest_result.vulnerabilities:
                severity_counts[vuln.severity.value] = severity_counts.get(vuln.severity.value, 0) + 1
                total_cvss += vuln.cvss_score
            
            stats["vulnerabilities"]["by_severity"] = severity_counts
            stats["vulnerabilities"]["average_cvss"] = total_cvss / len(pentest_result.vulnerabilities)
        
        return stats
