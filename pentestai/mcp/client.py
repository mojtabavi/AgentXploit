"""
MCP (Model Context Protocol) Client for Kali Linux Tools

Enables ExecutorAgent to communicate with Kali MCP Server for:
- Tool discovery
- Command execution
- Result retrieval
"""

import os
import logging
import shlex
from typing import List, Optional, Dict, Any
from dataclasses import dataclass

import httpx


logger = logging.getLogger(__name__)


@dataclass
class ToolInfo:
    """Information about a Kali tool"""
    name: str
    category: str
    description: str
    usage: str
    examples: List[str]
    installed: bool = True


@dataclass
class CommandResult:
    """Result from command execution"""
    success: bool
    tool: str
    command: str
    stdout: str
    stderr: str
    exit_code: int
    execution_time: float
    timestamp: str


class KaliMCPClient:
    """
    Client for Kali Linux MCP Server
    
    Provides interface to:
    - Discover available tools
    - Get tool information and examples
    - Execute commands on Kali Linux
    - Retrieve results safely
    """
    
    def __init__(self, base_url: Optional[str] = None, timeout: int = 300):
        """
        Initialize MCP client
        
        Args:
            base_url: URL of Kali MCP server (default: from env KALI_MCP_URL)
            timeout: Default timeout for requests in seconds
        """
        self.base_url = base_url or os.getenv("KALI_MCP_URL", "http://localhost:5000")
        self.timeout = timeout
        self.client = httpx.Client(base_url=self.base_url, timeout=self.timeout)
        
        logger.info(f"Initialized Kali MCP Client: {self.base_url}")
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.client.close()
    
    def health_check(self) -> bool:
        """
        Check if MCP server is healthy
        
        Returns:
            True if server is healthy, False otherwise
        """
        try:
            response = self.client.get("/health")
            return response.status_code == 200
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            return False
    
    def list_tools(self, category: Optional[str] = None) -> List[ToolInfo]:
        """
        List all available Kali tools
        
        Args:
            category: Optional filter by category
            
        Returns:
            List of available tools
        """
        try:
            if os.getenv("MCP_USE_TOOLS_ENDPOINT", "0") != "1":
                return self._fallback_tool_list()

            params = {"category": category} if category else {}
            response = self.client.get("/tools", params=params)
            if response.status_code == 404:
                return self._fallback_tool_list()
            response.raise_for_status()

            data = response.json()
            tools = [
                ToolInfo(
                    name=tool["name"],
                    category=tool.get("category", "unknown"),
                    description=tool.get("description", ""),
                    usage=tool.get("usage", ""),
                    examples=tool.get("examples", []),
                    installed=tool.get("installed", True),
                )
                for tool in data.get("tools", [])
            ]

            logger.info(f"Retrieved {len(tools)} tools from MCP server")
            return tools

        except Exception as e:
            logger.error(f"Failed to list tools: {e}")
            return self._fallback_tool_list()

    def _fallback_tool_list(self) -> List[ToolInfo]:
        """Fallback for MCP servers that do not expose /tools."""
        tools_status = {}
        try:
            response = self.client.get("/health")
            if response.status_code == 200:
                data = response.json()
                tools_status = data.get("tools_status", {})
        except Exception as e:
            logger.warning(f"Failed to read /health for tools list: {e}")

        fallback_tools = []
        for tool_name, installed in tools_status.items():
            fallback_tools.append(
                ToolInfo(
                    name=tool_name,
                    category="kali",
                    description="",
                    usage="",
                    examples=[],
                    installed=bool(installed),
                )
            )

        if not fallback_tools:
            fallback_tools = [
                ToolInfo(name="nmap", category="kali", description="", usage="", examples=[], installed=True),
                ToolInfo(name="gobuster", category="kali", description="", usage="", examples=[], installed=True),
                ToolInfo(name="dirb", category="kali", description="", usage="", examples=[], installed=True),
                ToolInfo(name="nikto", category="kali", description="", usage="", examples=[], installed=True),
            ]

        return fallback_tools
    
    def get_tool_info(self, tool_name: str) -> Optional[ToolInfo]:
        """
        Get detailed information about a specific tool
        
        Args:
            tool_name: Name of the tool
            
        Returns:
            Tool information or None if not found
        """
        try:
            if os.getenv("MCP_USE_TOOLS_ENDPOINT", "0") != "1":
                return self._fallback_tool_info(tool_name)

            response = self.client.get(f"/tools/{tool_name}")
            if response.status_code == 404:
                return self._fallback_tool_info(tool_name)
            response.raise_for_status()

            data = response.json()
            return ToolInfo(
                name=data.get("name", tool_name),
                category=data.get("category", "unknown"),
                description=data.get("description", ""),
                usage=data.get("usage", ""),
                examples=data.get("examples", []),
                installed=data.get("installed", True),
            )

        except httpx.HTTPStatusError as e:
            if e.response.status_code == 404:
                logger.warning(f"Tool '{tool_name}' not found")
            else:
                logger.error(f"Failed to get tool info: {e}")
            return None
        except Exception as e:
            logger.error(f"Failed to get tool info: {e}")
            return None

    def _fallback_tool_info(self, tool_name: str) -> Optional[ToolInfo]:
        tools = self._fallback_tool_list()
        for tool in tools:
            if tool.name == tool_name:
                return tool
        return ToolInfo(
            name=tool_name,
            category="kali",
            description="",
            usage="",
            examples=[],
            installed=False,
        )
    
    def execute_command(
        self,
        tool: str,
        command: str,
        timeout: Optional[int] = None,
        working_dir: Optional[str] = None
    ) -> CommandResult:
        """
        Execute a command on Kali Linux via MCP
        
        Args:
            tool: Tool name (e.g., 'nmap', 'sqlmap')
            command: Full command to execute
            timeout: Command timeout in seconds
            working_dir: Working directory for command
            
        Returns:
            Command execution result
        """
        try:
            payload = {
                "tool": tool,
                "command": command,
                "timeout": timeout or self.timeout,
            }
            if working_dir:
                payload["working_dir"] = working_dir

            logger.info(f"Executing command via MCP: {command}")

            data = self._call_tool_endpoint(tool, command)
            if data is None and os.getenv("MCP_USE_EXECUTE_ENDPOINT", "0") == "1":
                response = self.client.post("/execute", json=payload)
                if response.status_code != 404:
                    response.raise_for_status()
                    data = response.json()

            if data is None:
                response = self.client.post("/api/command", json={"command": command})
                response.raise_for_status()
                data = response.json()

            result = CommandResult(
                success=data.get("success", data.get("return_code", 1) == 0),
                tool=tool,
                command=command,
                stdout=data.get("stdout", ""),
                stderr=data.get("stderr", ""),
                exit_code=data.get("exit_code", data.get("return_code", -1)),
                execution_time=float(data.get("execution_time", 0.0)),
                timestamp=data.get("timestamp", "")
            )

            logger.info(f"Command completed: exit_code={result.exit_code}, time={result.execution_time}s")
            return result

        except httpx.HTTPStatusError as e:
            logger.error(f"Command execution failed with status {e.response.status_code}: {e}")
            # Return error result
            return CommandResult(
                success=False,
                tool=tool,
                command=command,
                stdout="",
                stderr=f"HTTP Error {e.response.status_code}: {e.response.text}",
                exit_code=-1,
                execution_time=0.0,
                timestamp=""
            )
        except Exception as e:
            logger.error(f"Command execution failed: {e}")
            return CommandResult(
                success=False,
                tool=tool,
                command=command,
                stdout="",
                stderr=str(e),
                exit_code=-1,
                execution_time=0.0,
                timestamp=""
            )

    def _call_tool_endpoint(self, tool: str, command: str) -> Optional[Dict[str, Any]]:
        """Call tool-specific endpoints when supported by the MCP server."""
        tool_params = self._parse_tool_params(tool, command)
        if not tool_params:
            return None

        try:
            response = self.client.post(f"/api/tools/{tool}", json=tool_params)
            if response.status_code == 404:
                return None
            response.raise_for_status()
            return response.json()
        except Exception as e:
            logger.warning(f"Tool endpoint failed for {tool}: {e}")
            return None

    def _parse_tool_params(self, tool: str, command: str) -> Optional[Dict[str, Any]]:
        tokens = shlex.split(command)
        if not tokens or tokens[0] != tool:
            return None

        if tool == "nmap":
            return self._parse_nmap(tokens)
        if tool == "gobuster":
            return self._parse_gobuster(tokens)
        if tool == "dirb":
            return self._parse_dirb(tokens)
        if tool == "nikto":
            return self._parse_nikto(tokens)
        if tool == "sqlmap":
            return self._parse_sqlmap(tokens)
        if tool == "wpscan":
            return self._parse_wpscan(tokens)
        if tool == "enum4linux":
            return self._parse_enum4linux(tokens)
        if tool == "hydra":
            return self._parse_hydra(tokens)
        if tool == "john":
            return self._parse_john(tokens)
        return None

    def _parse_nmap(self, tokens: List[str]) -> Optional[Dict[str, Any]]:
        if len(tokens) < 2:
            return None
        target = tokens[-1]
        ports = ""
        scan_type_parts = []
        additional_parts = []
        i = 1
        while i < len(tokens) - 1:
            token = tokens[i]
            if token == "-p" and i + 1 < len(tokens) - 1:
                ports = tokens[i + 1]
                i += 2
                continue
            if token.startswith("-s") or token in ("-A", "-O"):
                scan_type_parts.append(token)
            else:
                additional_parts.append(token)
            i += 1
        scan_type = " ".join(scan_type_parts) if scan_type_parts else "-sCV"
        additional_args = " ".join(additional_parts) if additional_parts else "-T4 -Pn"
        return {
            "target": target,
            "scan_type": scan_type,
            "ports": ports,
            "additional_args": additional_args,
        }

    def _parse_gobuster(self, tokens: List[str]) -> Optional[Dict[str, Any]]:
        mode = "dir"
        idx = 1
        if len(tokens) > 1 and tokens[1] in {"dir", "dns", "fuzz", "vhost"}:
            mode = tokens[1]
            idx = 2

        url = ""
        wordlist = ""
        additional_parts = []
        i = idx
        while i < len(tokens):
            token = tokens[i]
            if token in {"-u", "--url"} and i + 1 < len(tokens):
                url = tokens[i + 1]
                i += 2
                continue
            if token in {"-w", "--wordlist"} and i + 1 < len(tokens):
                wordlist = tokens[i + 1]
                i += 2
                continue
            additional_parts.append(token)
            i += 1

        if not url:
            return None
        return {
            "url": url,
            "mode": mode,
            "wordlist": wordlist or "/usr/share/wordlists/dirb/common.txt",
            "additional_args": " ".join(additional_parts),
        }

    def _parse_dirb(self, tokens: List[str]) -> Optional[Dict[str, Any]]:
        if len(tokens) < 2:
            return None
        url = tokens[1]
        wordlist = ""
        additional_parts = []
        if len(tokens) > 2 and not tokens[2].startswith("-"):
            wordlist = tokens[2]
            additional_parts = tokens[3:]
        else:
            additional_parts = tokens[2:]
        return {
            "url": url,
            "wordlist": wordlist or "/usr/share/wordlists/dirb/common.txt",
            "additional_args": " ".join(additional_parts),
        }

    def _parse_nikto(self, tokens: List[str]) -> Optional[Dict[str, Any]]:
        target = ""
        additional_parts = []
        i = 1
        while i < len(tokens):
            token = tokens[i]
            if token in {"-h", "-host"} and i + 1 < len(tokens):
                target = tokens[i + 1]
                i += 2
                continue
            additional_parts.append(token)
            i += 1
        if not target and len(tokens) > 1:
            target = tokens[-1]
        if not target:
            return None
        return {
            "target": target,
            "additional_args": " ".join(additional_parts),
        }

    def _parse_sqlmap(self, tokens: List[str]) -> Optional[Dict[str, Any]]:
        url = ""
        data = ""
        additional_parts = []
        i = 1
        while i < len(tokens):
            token = tokens[i]
            if token in {"-u", "--url"} and i + 1 < len(tokens):
                url = tokens[i + 1]
                i += 2
                continue
            if token.startswith("--data="):
                data = token.split("=", 1)[1]
                i += 1
                continue
            if token == "--data" and i + 1 < len(tokens):
                data = tokens[i + 1]
                i += 2
                continue
            additional_parts.append(token)
            i += 1
        if not url:
            return None
        return {
            "url": url,
            "data": data,
            "additional_args": " ".join(additional_parts),
        }

    def _parse_wpscan(self, tokens: List[str]) -> Optional[Dict[str, Any]]:
        url = ""
        additional_parts = []
        i = 1
        while i < len(tokens):
            token = tokens[i]
            if token == "--url" and i + 1 < len(tokens):
                url = tokens[i + 1]
                i += 2
                continue
            additional_parts.append(token)
            i += 1
        if not url:
            return None
        return {
            "url": url,
            "additional_args": " ".join(additional_parts),
        }

    def _parse_enum4linux(self, tokens: List[str]) -> Optional[Dict[str, Any]]:
        if len(tokens) < 2:
            return None
        target = tokens[-1]
        additional_parts = tokens[1:-1]
        return {
            "target": target,
            "additional_args": " ".join(additional_parts) or "-a",
        }

    def _parse_hydra(self, tokens: List[str]) -> Optional[Dict[str, Any]]:
        if len(tokens) < 4:
            return None
        target = tokens[-2]
        service = tokens[-1]
        username = ""
        username_file = ""
        password = ""
        password_file = ""
        additional_parts = []
        i = 1
        while i < len(tokens) - 2:
            token = tokens[i]
            if token == "-l" and i + 1 < len(tokens) - 2:
                username = tokens[i + 1]
                i += 2
                continue
            if token == "-L" and i + 1 < len(tokens) - 2:
                username_file = tokens[i + 1]
                i += 2
                continue
            if token == "-p" and i + 1 < len(tokens) - 2:
                password = tokens[i + 1]
                i += 2
                continue
            if token == "-P" and i + 1 < len(tokens) - 2:
                password_file = tokens[i + 1]
                i += 2
                continue
            additional_parts.append(token)
            i += 1
        if not target or not service:
            return None
        return {
            "target": target,
            "service": service,
            "username": username,
            "username_file": username_file,
            "password": password,
            "password_file": password_file,
            "additional_args": " ".join(additional_parts),
        }

    def _parse_john(self, tokens: List[str]) -> Optional[Dict[str, Any]]:
        if len(tokens) < 2:
            return None
        hash_file = ""
        wordlist = ""
        format_type = ""
        additional_parts = []
        i = 1
        while i < len(tokens):
            token = tokens[i]
            if token.startswith("--wordlist="):
                wordlist = token.split("=", 1)[1]
                i += 1
                continue
            if token == "--wordlist" and i + 1 < len(tokens):
                wordlist = tokens[i + 1]
                i += 2
                continue
            if token.startswith("--format="):
                format_type = token.split("=", 1)[1]
                i += 1
                continue
            if token == "--format" and i + 1 < len(tokens):
                format_type = tokens[i + 1]
                i += 2
                continue
            additional_parts.append(token)
            i += 1
        if additional_parts:
            hash_file = additional_parts[-1]
            additional_parts = additional_parts[:-1]
        if not hash_file:
            return None
        return {
            "hash_file": hash_file,
            "wordlist": wordlist or "/usr/share/wordlists/rockyou.txt",
            "format": format_type,
            "additional_args": " ".join(additional_parts),
        }
    
    def list_categories(self) -> List[str]:
        """
        List all available tool categories
        
        Returns:
            List of category names
        """
        try:
            response = self.client.get("/categories")
            response.raise_for_status()
            
            data = response.json()
            return data["categories"]
            
        except Exception as e:
            logger.error(f"Failed to list categories: {e}")
            return []
    
    def get_tool_suggestions(self, task_description: str) -> List[ToolInfo]:
        """
        Get tool suggestions based on task description
        
        Args:
            task_description: Description of the pentesting task
            
        Returns:
            List of suggested tools
        """
        # Simple keyword matching for tool suggestions
        task_lower = task_description.lower()
        
        # Get all tools
        all_tools = self.list_tools()
        
        # Filter tools by keywords
        suggestions = []
        for tool in all_tools:
            if any(keyword in task_lower for keyword in [
                tool.name,
                tool.category.replace("-", " "),
                *tool.description.lower().split()[:5]
            ]):
                suggestions.append(tool)
        
        return suggestions
    
    def close(self):
        """Close the HTTP client"""
        self.client.close()


# Convenience function for one-off requests
def create_mcp_client(base_url: Optional[str] = None) -> KaliMCPClient:
    """
    Create a new MCP client instance
    
    Args:
        base_url: Optional custom base URL
        
    Returns:
        KaliMCPClient instance
    """
    return KaliMCPClient(base_url=base_url)
