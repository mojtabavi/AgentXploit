"""
MCP (Model Context Protocol) Client for Kali Linux Tools

Enables ExecutorAgent to communicate with Kali MCP Server for:
- Tool discovery
- Command execution
- Result retrieval
"""

import os
import logging
from typing import List, Optional, Dict, Any
from dataclasses import dataclass

import httpx


logger = logging.getLogger(__name__)


@dataclass
class ToolInfo:
    """Information about a Kali tool"""
    name: str
    category: str
    description: str
    usage: str
    examples: List[str]
    installed: bool = True


@dataclass
class CommandResult:
    """Result from command execution"""
    success: bool
    tool: str
    command: str
    stdout: str
    stderr: str
    exit_code: int
    execution_time: float
    timestamp: str


class KaliMCPClient:
    """
    Client for Kali Linux MCP Server
    
    Provides interface to:
    - Discover available tools
    - Get tool information and examples
    - Execute commands on Kali Linux
    - Retrieve results safely
    """
    
    def __init__(self, base_url: Optional[str] = None, timeout: int = 300):
        """
        Initialize MCP client
        
        Args:
            base_url: URL of Kali MCP server (default: from env KALI_MCP_URL)
            timeout: Default timeout for requests in seconds
        """
        self.base_url = base_url or os.getenv("KALI_MCP_URL", "http://localhost:5000")
        self.timeout = timeout
        self.client = httpx.Client(base_url=self.base_url, timeout=self.timeout)
        
        logger.info(f"Initialized Kali MCP Client: {self.base_url}")
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.client.close()
    
    def health_check(self) -> bool:
        """
        Check if MCP server is healthy
        
        Returns:
            True if server is healthy, False otherwise
        """
        try:
            response = self.client.get("/health")
            return response.status_code == 200
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            return False
    
    def list_tools(self, category: Optional[str] = None) -> List[ToolInfo]:
        """
        List all available Kali tools
        
        Args:
            category: Optional filter by category
            
        Returns:
            List of available tools
        """
        try:
            params = {"category": category} if category else {}
            response = self.client.get("/tools", params=params)
            response.raise_for_status()
            
            data = response.json()
            tools = [
                ToolInfo(
                    name=tool["name"],
                    category=tool["category"],
                    description=tool["description"],
                    usage=tool["usage"],
                    examples=tool["examples"],
                    installed=tool["installed"]
                )
                for tool in data["tools"]
            ]
            
            logger.info(f"Retrieved {len(tools)} tools from MCP server")
            return tools
            
        except Exception as e:
            logger.error(f"Failed to list tools: {e}")
            return []
    
    def get_tool_info(self, tool_name: str) -> Optional[ToolInfo]:
        """
        Get detailed information about a specific tool
        
        Args:
            tool_name: Name of the tool
            
        Returns:
            Tool information or None if not found
        """
        try:
            response = self.client.get(f"/tools/{tool_name}")
            response.raise_for_status()
            
            data = response.json()
            return ToolInfo(
                name=data["name"],
                category=data["category"],
                description=data["description"],
                usage=data["usage"],
                examples=data["examples"],
                installed=data["installed"]
            )
            
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 404:
                logger.warning(f"Tool '{tool_name}' not found")
            else:
                logger.error(f"Failed to get tool info: {e}")
            return None
        except Exception as e:
            logger.error(f"Failed to get tool info: {e}")
            return None
    
    def execute_command(
        self,
        tool: str,
        command: str,
        timeout: Optional[int] = None,
        working_dir: Optional[str] = None
    ) -> CommandResult:
        """
        Execute a command on Kali Linux via MCP
        
        Args:
            tool: Tool name (e.g., 'nmap', 'sqlmap')
            command: Full command to execute
            timeout: Command timeout in seconds
            working_dir: Working directory for command
            
        Returns:
            Command execution result
        """
        try:
            payload = {
                "tool": tool,
                "command": command,
                "timeout": timeout or self.timeout,
            }
            if working_dir:
                payload["working_dir"] = working_dir
            
            logger.info(f"Executing command via MCP: {command}")
            
            response = self.client.post("/execute", json=payload)
            response.raise_for_status()
            
            data = response.json()
            result = CommandResult(
                success=data["success"],
                tool=data["tool"],
                command=data["command"],
                stdout=data["stdout"],
                stderr=data["stderr"],
                exit_code=data["exit_code"],
                execution_time=data["execution_time"],
                timestamp=data["timestamp"]
            )
            
            logger.info(f"Command completed: exit_code={result.exit_code}, time={result.execution_time}s")
            return result
            
        except httpx.HTTPStatusError as e:
            logger.error(f"Command execution failed with status {e.response.status_code}: {e}")
            # Return error result
            return CommandResult(
                success=False,
                tool=tool,
                command=command,
                stdout="",
                stderr=f"HTTP Error {e.response.status_code}: {e.response.text}",
                exit_code=-1,
                execution_time=0.0,
                timestamp=""
            )
        except Exception as e:
            logger.error(f"Command execution failed: {e}")
            return CommandResult(
                success=False,
                tool=tool,
                command=command,
                stdout="",
                stderr=str(e),
                exit_code=-1,
                execution_time=0.0,
                timestamp=""
            )
    
    def list_categories(self) -> List[str]:
        """
        List all available tool categories
        
        Returns:
            List of category names
        """
        try:
            response = self.client.get("/categories")
            response.raise_for_status()
            
            data = response.json()
            return data["categories"]
            
        except Exception as e:
            logger.error(f"Failed to list categories: {e}")
            return []
    
    def get_tool_suggestions(self, task_description: str) -> List[ToolInfo]:
        """
        Get tool suggestions based on task description
        
        Args:
            task_description: Description of the pentesting task
            
        Returns:
            List of suggested tools
        """
        # Simple keyword matching for tool suggestions
        task_lower = task_description.lower()
        
        # Get all tools
        all_tools = self.list_tools()
        
        # Filter tools by keywords
        suggestions = []
        for tool in all_tools:
            if any(keyword in task_lower for keyword in [
                tool.name,
                tool.category.replace("-", " "),
                *tool.description.lower().split()[:5]
            ]):
                suggestions.append(tool)
        
        return suggestions
    
    def close(self):
        """Close the HTTP client"""
        self.client.close()


# Convenience function for one-off requests
def create_mcp_client(base_url: Optional[str] = None) -> KaliMCPClient:
    """
    Create a new MCP client instance
    
    Args:
        base_url: Optional custom base URL
        
    Returns:
        KaliMCPClient instance
    """
    return KaliMCPClient(base_url=base_url)
