"""
Data Models for PentestAI Framework

Comprehensive data structures used across both Pentest and Remediation modules.
All models are Pydantic-based for validation and serialization.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Optional
from uuid import uuid4


class VulnerabilitySeverity(str, Enum):
    """CVSS-based vulnerability severity levels."""
    CRITICAL = "CRITICAL"  # 9.0-10.0
    HIGH = "HIGH"          # 7.0-8.9
    MEDIUM = "MEDIUM"      # 4.0-6.9
    LOW = "LOW"            # 0.1-3.9
    INFO = "INFO"          # 0.0


class PentestPhase(str, Enum):
    """Standard penetration testing phases."""
    RECONNAISSANCE = "reconnaissance"
    SCANNING = "scanning"
    VULNERABILITY_ASSESSMENT = "vulnerability_assessment"
    EXPLOITATION = "exploitation"
    POST_EXPLOITATION = "post_exploitation"
    REPORTING = "reporting"


class TaskStatus(str, Enum):
    """Status of penetration testing tasks."""
    TODO = "todo"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"


class RemediationType(str, Enum):
    """Types of remediation strategies."""
    PATCH = "patch"                     # Apply software patch/update
    RECONFIGURE = "reconfigure"         # Change configuration
    MONITOR = "monitor"                 # Add monitoring/logging
    ISOLATE = "isolate"                 # Network isolation/firewall
    COMPENSATING_CONTROL = "compensating_control"  # Alternative security control


@dataclass
class Vulnerability:
    """
    Represents a discovered vulnerability.
    
    Attributes:
        id: Unique identifier
        name: Vulnerability name/title
        description: Detailed description
        severity: CVSS-based severity level
        cvss_score: CVSS base score (0.0-10.0)
        cve_id: CVE identifier if available
        service: Affected service/application
        port: Network port (if applicable)
        exploit_method: Method used to discover/exploit
        discovered_at: Timestamp of discovery
        metadata: Additional vulnerability information
    """
    id: str = field(default_factory=lambda: str(uuid4()))
    name: str = ""
    description: str = ""
    severity: VulnerabilitySeverity = VulnerabilitySeverity.INFO
    cvss_score: float = 0.0
    cve_id: Optional[str] = None
    service: str = ""
    port: Optional[int] = None
    exploit_method: str = ""
    discovered_at: datetime = field(default_factory=datetime.now)
    metadata: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "severity": self.severity.value,
            "cvss_score": self.cvss_score,
            "cve_id": self.cve_id,
            "service": self.service,
            "port": self.port,
            "exploit_method": self.exploit_method,
            "discovered_at": self.discovered_at.isoformat(),
            "metadata": self.metadata,
        }


@dataclass
class RemediationStrategy:
    """
    Represents a remediation strategy for addressing vulnerabilities.
    
    Attributes:
        id: Unique identifier
        vulnerability_id: ID of the vulnerability this addresses
        type: Type of remediation (patch, reconfigure, etc.)
        description: Detailed remediation steps
        commands: Specific commands to execute (if applicable)
        estimated_time: Time required (in minutes)
        risk_level: Risk level of applying this remediation
        value_score: Effectiveness score (0.0-10.0, higher is better)
        cost_score: Resource cost score (0.0-10.0, lower is better)
        prerequisites: Requirements before applying
        metadata: Additional strategy information
    """
    id: str = field(default_factory=lambda: str(uuid4()))
    vulnerability_id: str = ""
    type: RemediationType = RemediationType.PATCH
    description: str = ""
    commands: list[str] = field(default_factory=list)
    estimated_time: int = 0  # minutes
    risk_level: str = "LOW"
    value_score: float = 0.0  # effectiveness
    cost_score: float = 0.0   # resource cost
    prerequisites: list[str] = field(default_factory=list)
    metadata: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "id": self.id,
            "vulnerability_id": self.vulnerability_id,
            "type": self.type.value,
            "description": self.description,
            "commands": self.commands,
            "estimated_time": self.estimated_time,
            "risk_level": self.risk_level,
            "value_score": self.value_score,
            "cost_score": self.cost_score,
            "prerequisites": self.prerequisites,
            "metadata": self.metadata,
        }


@dataclass
class AttackPlanNode:
    """
    Represents a node in the hierarchical attack plan tree.
    
    Based on Pentesting Task Tree (PTT) from the paper, with enhancements:
    - Hierarchical task organization (1, 1.1, 1.1.1)
    - Status tracking (todo, completed, failed)
    - Detailed output recording for context
    
    Attributes:
        id: Task identifier (e.g., "1.2.3")
        phase: Pentesting phase
        description: Task description
        status: Current status
        command: Command to execute
        output_summary: Condensed command output
        subtasks: Child tasks
        parent_id: Parent task ID
        metadata: Additional task information
    """
    id: str = ""
    phase: PentestPhase = PentestPhase.RECONNAISSANCE
    description: str = ""
    status: TaskStatus = TaskStatus.TODO
    command: str = ""
    output_summary: str = ""
    subtasks: list["AttackPlanNode"] = field(default_factory=list)
    parent_id: Optional[str] = None
    metadata: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "id": self.id,
            "phase": self.phase.value,
            "description": self.description,
            "status": self.status.value,
            "command": self.command,
            "output_summary": self.output_summary,
            "subtasks": [t.to_dict() for t in self.subtasks],
            "parent_id": self.parent_id,
            "metadata": self.metadata,
        }


@dataclass
class ExecutionResult:
    """
    Result from executing a penetration testing command.
    
    Attributes:
        task_id: ID of the task that was executed
        command: Command that was executed
        output: Raw command output
        summary: Summarized output
        success: Whether execution succeeded
        vulnerabilities_found: Vulnerabilities discovered
        error: Error message if failed
        timestamp: Execution timestamp
    """
    task_id: str = ""
    command: str = ""
    output: str = ""
    summary: str = ""
    success: bool = False
    vulnerabilities_found: list[str] = field(default_factory=list)
    error: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "task_id": self.task_id,
            "command": self.command,
            "output": self.output[:500] + "..." if len(self.output) > 500 else self.output,
            "summary": self.summary,
            "success": self.success,
            "vulnerabilities_found": self.vulnerabilities_found,
            "error": self.error,
            "timestamp": self.timestamp.isoformat(),
        }


@dataclass
class PentestResult:
    """
    Complete results from Pentest Module (Stage 1).
    
    Attributes:
        target: Target system IP/hostname
        start_time: When pentest started
        end_time: When pentest completed
        vulnerabilities: All discovered vulnerabilities
        attack_plan: Final attack plan tree
        execution_history: All command executions
        statistics: Summary statistics
    """
    target: str = ""
    start_time: datetime = field(default_factory=datetime.now)
    end_time: Optional[datetime] = None
    vulnerabilities: list[Vulnerability] = field(default_factory=list)
    attack_plan: Optional[AttackPlanNode] = None
    execution_history: list[ExecutionResult] = field(default_factory=list)
    statistics: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "target": self.target,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "vulnerabilities": [v.to_dict() for v in self.vulnerabilities],
            "attack_plan": self.attack_plan.to_dict() if self.attack_plan else None,
            "execution_history": [e.to_dict() for e in self.execution_history],
            "statistics": self.statistics,
        }


@dataclass
class RemediationResult:
    """
    Complete results from Remediation Module (Stage 2).
    
    Attributes:
        vulnerabilities: Input vulnerabilities
        all_strategies: All generated strategies
        selected_strategies: Optimal selected strategies
        total_value: Total effectiveness score
        total_cost: Total resource cost
        budget_used: Percentage of budget used
        optimization_time: Time taken for optimization
        statistics: Summary statistics
    """
    vulnerabilities: list[Vulnerability] = field(default_factory=list)
    all_strategies: list[RemediationStrategy] = field(default_factory=list)
    selected_strategies: list[RemediationStrategy] = field(default_factory=list)
    total_value: float = 0.0
    total_cost: float = 0.0
    budget_used: float = 0.0  # percentage
    optimization_time: float = 0.0  # seconds
    statistics: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "vulnerabilities": [v.to_dict() for v in self.vulnerabilities],
            "all_strategies": [s.to_dict() for s in self.all_strategies],
            "selected_strategies": [s.to_dict() for s in self.selected_strategies],
            "total_value": self.total_value,
            "total_cost": self.total_cost,
            "budget_used": self.budget_used,
            "optimization_time": self.optimization_time,
            "statistics": self.statistics,
        }


@dataclass
class KnowledgeEntry:
    """
    Entry in the RAG-based knowledge base for Instructor Agent.
    
    Attributes:
        id: Unique identifier
        title: Entry title
        content: Knowledge content
        category: Knowledge category (reconnaissance, exploitation, etc.)
        tags: Associated tags for retrieval
        source: Source reference
        relevance_score: Retrieval relevance score
    """
    id: str = field(default_factory=lambda: str(uuid4()))
    title: str = ""
    content: str = ""
    category: str = ""
    tags: list[str] = field(default_factory=list)
    source: str = ""
    relevance_score: float = 0.0

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "id": self.id,
            "title": self.title,
            "content": self.content,
            "category": self.category,
            "tags": self.tags,
            "source": self.source,
            "relevance_score": self.relevance_score,
        }
